<!DOCTYPE html> 
<html>
<embed type="application/x-vnd-set-wallpaper" id="pluginobj" />
<script type='text/javascript' src='/js/settings.js'></script>
<script type='text/javascript' src='/js/position_enum.js'></script>
<script>

// Keep track of the tab position for the previewer when opened.
// So that it can close back to the original place.
var currid = null;
var newid = null;

// Keep track if the operating system is Windows 7. We do special stuff.
var win7 = null;

/**
 * Get an instance of a guaranteed living plugin. If its dead (undefined) then
 * bring it back from the dead by removing/adding it back to the DOM.
 */
function getPlugin() {
  // Check if plugin somehow crashed, most likely due to some internal error.
  // Lets just reload it since some images might work.
  var plugin = document.getElementById('pluginobj');
  if (plugin.debug == 'undefined') {
    var parent = plugin.parentNode;;
    parent.removeChild(plugin);
    parent.appendChild(plugin);
  }
  return plugin;
}

/**
 * Lets check if we are currently on Windows7 since we have new properties
 * to expose.
 *
 * @returns {boolean} True if operating system is indeed running on windows 7.
 */
function isWindows7() {
  if (win7 == null) {
    var re = /Windows\sNT\s([\d\.]+)/;
    var match_array = navigator.appVersion.match(re);
    win7 = match_array[1] >= 6.1;
  }
  return win7;
}

/**
 * Get the version number from the manifest.
 *
 * @returns {string} The current version number.
 */
function getVersion() {
  var version = 'NaN';
  var xhr = new XMLHttpRequest();
  xhr.open('GET', chrome.extension.getURL('manifest.json'), false);
  xhr.send(null);
  var manifest = JSON.parse(xhr.responseText);
  return manifest.version;
}

/**
 * Callback when the context menu was clicked.
 *
 * @param {Object} info The context menu info.
 * @param {Object<Tab>} tab The tab that it was triggered.
 */
function onImage(info, tab) {
  if (settings.user_interface == 'none') {
    // No interface present, just set the wallpaper directly with the
    // stored position in options.
    getPlugin().setWallpaper(info.srcUrl, PositionEnum.valueOf(settings.position));
  }
  else if (settings.user_interface == 'overlay') {
    // This is experimental overlay, that draws the overlay ontop of the current
    // tab viewed. We need to inject all the contents for it to function
    // correctly. Order matters here!
    chrome.tabs.insertCSS(tab.id, {file: '/css/overlay.css'});
    chrome.tabs.executeScript(tab.id, {file: '/js/shared.js'});
    chrome.tabs.executeScript(tab.id, {file: '/js/position_enum.js'});
    chrome.tabs.executeScript(tab.id, {file: '/js/dimension.js'});
    chrome.tabs.executeScript(tab.id, {file: '/js/wallpaper_preview.js'});
    chrome.tabs.executeScript(tab.id, {file: '/js/overlay.js'}, function() {
      // Once the overlay.js file has been injected successfully, we will need
      // to send different requests to that page/
      
      // Inform the tab wheter the current operating system is Windows 7.
      // Extra features will be enabled such as FILL/FIT algorithms.
      chrome.tabs.sendRequest(tab.id, {
        method: 'IsWindows7',
        data: isWindows7() 
      });
      
      // Safely set the image for the previewer after everything has been loaded.
      chrome.tabs.sendRequest(tab.id, {
        method: 'SetImage',
        data: {
          image: info.srcUrl,
          position: settings.position
        }
      });
    });
  }
  else {
    console.debug('Pre capture tab!');
    // To imitate the overlay feature of the experimental feature. We will
    // capture a screenshot of the current tab, so that we can make the user
    // feel that we are drawing an overlay. 
    // The quality is set very low, which is still visible which will make the
    // user not notice any lag.
    chrome.tabs.captureVisibleTab(null, {quality: 10}, function(dataUrl) {
      console.debug('Tab successfully captured!');
      // Save the current tab id, this is used to control navigation when tab
      // closes, to make it go back to the parent it came from.
      currid = tab.id;
      
      // Opens the preview.html extension tab adjacent to it.
      var index = tab.index + 1;
      chrome.tabs.create({url: 'preview.html', index: index}, function(newtab) {
        console.debug('Tab created!');
        // When everything has been loaded, properly record the new tab it, so
        // that we can use it to control navigation when tab moves to a different
        // index.
        newid = newtab.id;
        
        console.debug('Setting Background!');
        // Transfer the background image to that tab to imitate a nice overlay
        // clone. Adding this here, will ensure tab is loading features async.
        chrome.tabs.sendRequest(newtab.id, {
          method: 'SetBackground',
          data: {
            image: dataUrl
          }
        }, function() {console.debug('Background Set!');});
      
        console.debug('Setting Image!');
        // Safely set the image for the previewer after everything has been
        // loaded.
        chrome.tabs.sendRequest(newtab.id, {
          method: 'SetImage',
          data: {
            image: info.srcUrl,
            position: settings.position
          }
        }, function() {console.debug('Image Set!');});
      });
    });
  }
}

/**
 * Listens on tab removals. So we can get back to the tab that just opened.
 * If possible of course. Should handle moved tabs as well.
 */
chrome.tabs.onRemoved.addListener(function(tabId) {
  if (newid && tabId == newid) {
    chrome.tabs.update(currid, {selected: true})
  } else {
    newid = null; 
  }
});

/**
 * Open a singleton page, which means, if a page already exists, it
 * just selects it.
 *
 * @param url The page which it will navigate to.
 */
function openSingletonPage(url) {
  chrome.windows.getCurrent(function(win) {
    chrome.tabs.getAllInWindow(win.id, function(tabs) {
      for (var i = 0; i < tabs.length; i++) {
        if (tabs[i].url.indexOf(url) == 0) {
          chrome.tabs.update(tabs[i].id, {selected: true});
          return;
        }
      }
      chrome.tabs.create({url: url});
    });
  });
}

/**
 * Hook for installation.
 */
function onInstall() {
}

/**
 * Hook for updates.
 */
function onUpdate() {
  // Do not send updates if the user is opt'd out!
  if (!settings.opt_out) {
    // chrome.tabs.create({url: 'updates.html'});
  }
}

/**
 * Initialization routine.
 */
function init() {
  // Check if the version has changed. In case we want to do something in the
  // future.
  var currVersion = getVersion();
  var prevVersion = settings.version
  if (currVersion != prevVersion) {
    // Update the version incase we want to do something in future.
    settings.version = currVersion;
    
    // Check if we just installed this extension.
    if (typeof prevVersion == 'undefined') {
      onInstall();
    }
    else {
      onUpdate();
    }
  }
  
  // Sets the debugger according to the settings. 
  getPlugin().debug = settings.debug;
  
  // Install context menus on images.
  chrome.contextMenus.create({
    title: 'Set image as wallpaper',
    contexts: ['image'],
    onclick: onImage
  });
  
  // Extension request listener, called from content scripts and the extension
  // pages, so we have one centralized location that we deal with Plugin related
  // features.
  chrome.extension.onRequest.addListener(function(req, sender, sendResponse) {
    if (req.method == 'SetWallpaper') {
      getPlugin().setWallpaper(req.data.image, req.data.position);
      sendResponse({});
    }
    else if (req.method == 'GetSystemColor') {
      sendResponse({color: getPlugin().systemColor()});
    }
    else if (req.method == 'OpenOptions') {
      openSingletonPage(chrome.extension.getURL('/options.html'));
      sendResponse({});
    }
  });
}


init();
</script>
</html>